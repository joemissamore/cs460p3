#include <iostream>
#include <fstream>
#include "CodeGenerator.h"

#define DEBUG 1
#define debug if (DEBUG) cout

using namespace std;

CodeGen::CodeGen (string filename, LexicalAnalyzer * L)
{
	lex = L;
	string cppname = filename.substr (0, filename.length()-3) + ".cpp"; 
	cpp.open (cppname.c_str());
	cpp << "// Autogenerated Scheme to C++ Code\n";
	cpp << "// File: " << cppname << "\n";
	cpp << "#include <iostream>\n";
	cpp << "#include \"Object.h\"\n";
	cpp << "using namespace std;\n\n";

	ParseCode();
}

/********************************************************************************/
/* This function will								*/
/********************************************************************************/
CodeGen::~CodeGen ()
{
	cpp.close();
}

/********************************************************************************/
/* This function will								*/
/********************************************************************************/
void CodeGen::WriteCode (int tabs, string code)
{
	for (int t = 0; t < tabs; t++)
		cpp << '\t';
	cpp << code;
}


/* Helper Functions */
void CodeGen::AdvanceTokenTo(token_type t)
{
	while (token != t)
		GetTokLex();
}

void CodeGen::GetTokLex()
{
	token = lex->GetToken();
	lexeme = lex->GetLexeme();
}

/* Debugging */
void CodeGen::Debug(string function)
{
	debug << "-------------------------------" << endl;
	debug << "Inside: " << function << endl;
	debug << "Token name: " + lex->GetTokenName(token) << endl;
	debug << "Lexeme: " + lex->GetLexeme() << endl;
	debug << "-------------------------------" << endl;
}

template<typename A> void CodeGen::PrintQ(A q)
{
	debug << "-------------------------------" << endl;
	debug << "Printing Queue..." << endl;
	while (!q.empty())
	{
		debug << q.front() << endl;
		q.pop();
	}
	debug << "-------------------------------" << endl;
}

/* Transition functions */
void CodeGen::ParseCode()
{
	GetTokLex();
	while (token != EOF_T)
	{
		Debug("ParseCode()");
		if (token == DEFINE_T)
			Define();
		
		GetTokLex();
	}

	WriteCode(1, "return 0;\n");
	WriteCode(0, "}");
	Debug("ParseCode() - exiting function");
}

void CodeGen::Define()
{
	AdvanceTokenTo(IDENT_T);

	lexeme = lex->GetLexeme();
	if (lexeme == "main")
	{
		WriteCode(0, 
			"int main("
		);
	}

	GetTokLex();
	Param_List();

	if (token == RPAREN_T)
	{
		WriteCode(0, ")\n{\n");
		GetTokLex();
	}

	Stmt();
	Debug("Define() - exited Stmt()");
	Stmt_List();
	Debug("Define() - exited Stmt_List()");

}

void CodeGen::Param_List()
{
	Debug("Param_List()");
	while (token == IDENT_T)
	{
		WriteCode(0, lex->GetLexeme() + " ");
		GetTokLex();
	}
}

void CodeGen::Stmt()
{
	Debug("Stmt()");
	if (token == IDENT_T)
	{
		// Do something
	}
	else if (token == LPAREN_T)
	{
		/* Its an action */
		GetTokLex();
		Action();
		GetTokLex(); // Digest ')'
	}
	else 
		Literal();
}

void CodeGen::Stmt_List()
{
	Debug("Stmt_List()");

	//TODO: IDENT_T
	if (token == LPAREN_T)
		Stmt();
}

void CodeGen::Action()
{
	Debug("Action()");

	switch (token)
	{
		case DISPLAY_T:
			WriteCode(1, "cout << ");
			GetTokLex();
			Stmt();
			break;

		case PLUS_T:
			GetTokLex();
			PLUS();
			break;

		case NEWLINE_T:
			Debug("Action() - NEWLINE_T");
			WriteCode(1, "cout << endl;\n");
			GetTokLex();

		default:
			// Its an error
			// TODO: Handle errors
			break;
	}
}

void CodeGen::Literal()
{
	
}

/* Actions */
void CodeGen::PLUS()
{
	Debug("PLUS()");
	/* By the time this function is 
	 * entered the number of LPAREN_T
	 * will be 1 and we will have also
	 * passed a '+' so this will be added
	 * to the queue. 
	 * 
	 * TODO: Make this for all arithmetic */

	queue<string> vals;
	queue<string> symbols;
	symbols.push("+");
	int numLPAREN_T = 1;
	int numRPARENT_T = 0;

	/* Assuming no syntax/lexical errs */
	while (numLPAREN_T != numRPARENT_T)
	{
		if (token == PLUS_T)
		{
			symbols.push("+");
			GetTokLex();
		}
			
		if (token == NUMLIT_T)
		{
			Debug("NUMLIT_T");
			vals.push(lexeme);
			GetTokLex();
		}

		if (token == LPAREN_T)
		{
			numLPAREN_T++;
			GetTokLex();
		}

		if (token == RPAREN_T)
		{
			numRPARENT_T++;
			// GetTokLex();
		}

		
	}
	
	PrintQ(symbols);
	PrintQ(vals);
	// debug << "Exited while loop" << endl;

	for (int i = 0; !vals.empty(); i++)
	{
		if (i % 2 == 0)
		{
			string str = "Object(" + vals.front() + ")";
			WriteCode(0, str);
			vals.pop();
			if (vals.size() != 0)
				WriteCode(0, " ");
		}
		else 
		{
			WriteCode(0, symbols.front() + " ");
			symbols.pop();
		}
		
	}
	WriteCode(0, ";\n");

}

